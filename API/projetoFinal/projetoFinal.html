<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Projeto Final</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Lexend+Deca&display=swap');

    * {
      color: white;
    }

    html {
      display: flex;
      flex-direction: column;
    }

    body {
      background-color: #1e1647;
      width: 80vw;
      align-self: center;
    }

    h1,
    h2,
    h3,
    span,
    a,
    p,
    li {
      font-family: 'Lexend Deca', sans-serif;
      font-weight: 400;
    }

    h1,
    h2,
    h3,
    span,
    p,
    li {
      margin: 10px 20px;
    }

    h1 {
      font-size: 24px;
    }

    h2 {
      font-size: 20px;
    }

    h3 {
      font-size: 16px;
    }


    h3,
    span {
      color: #614ad3 !important;
    }

    a {
      text-decoration: none;
      color: yellow;
    }

    a:hover {
      font-weight: bold;
      color: yellow;
      text-decoration: none;
      text-decoration-line: underline;
      text-decoration-color: yellow;
    }

    p,
    li {
      text-align: justify;
      font-size: 12px;
    }

    img {
      max-width: 100%;
    }

    .aligncenter {
      text-align: center;
      max-width: 100%;
    }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <h1>Projeto Final</h1>
  <h2>Um Modelo Não-Linear para a Otimização de um Processo de Separação de Elementos de Terras-Raras (ETR)</h2>
  <h3>Contexto e Fundamentos</h3>
  <p>Considere um sistema, conforme a figura abaixo, de separação de duas espécies químicas, utilizando <a
      href="https://pt.wikipedia.org/wiki/Extra%C3%A7%C3%A3o_l%C3%ADquido-l%C3%ADquido">extração por solvente</a>, para
    isso.</p>
  <p class="aligncenter"><img
      src="https://lh3.googleusercontent.com/FLxgUKGIyPoxcQP23aRNmFFJwhnGuFwTAYgHXcTw553MgJAWJh2yLxTnYTuXgi-_t3VCK79-3Sh4hvWw3ncY5Kvyl4NRbUbE-mmAx3jBUqxkD_GOOb6px7PDaYinz8pBCfE1YdT_rA=w2400"
      alt="tempo de equilíbrio"></p>

  <p>O problema central de um modelo para um processo de extração é conseguir prever razoavelmente a <a
      href="https://pt.wikipedia.org/wiki/Coeficiente_de_parti%C3%A7%C3%A3o">razão de distribuição (D)</a> das
    espécies
    a serem separadas. Quando um produto comercial só possui valor com purezas altíssimas, digamos 99%, ou 99.9% (até
    mesmo 99.999% para algumas aplicações), uma mínima incongruência do modelo com a realidade pode gerar uma mínima
    diferença entre a meta de pureza e o resultado obtido suficiente para acabar com o valor do produto.</p>
  <p>
    Ao longo do curso, muito se falou sobre etapas no processo de extração e separação, principalmente no contexto dos
    elementos de terras-raras. Ao longo do curso, apresentou-se modelos lineares (Semana 6 - Problemas 1, 2 e 3) e
    não-lineares (Semana 2 - Problema 2).
  </p>
  <p>
    A classe de modelos lineares é muito conveniente de se utilizar, porque resolver um grande conjunto de equações
    lineares é uma tarefa relativamente simples (como vimos nas Semanas 6 e 7). Entretanto, eles caem por terra para
    quase todas as aplicações, sobretudo porque as condições que preveem uma razão de distribuição constante (premissa
    do modelo linear), não se mantém para quase todos os processos.
  </p>
  <p>
    O modelo não-linear apresentado na Semana 2 sofre do problema de demandar uma bateria muito grande de
    experimentos,
    e uma incerteza associada muito grande, ambos porque ele trabalha com três variáveis (pH, concentração dos cátions
    \(Etr^{3+}\) e concentração de extratante livre), passíveis de alterar a razão de distribuição das
    espécies.
  </p>
  <p>
    Para alguns casos, entretanto, um modelo não-linear, porém mais simples, pode ser desenhado, que conta com uma
    robustez maior que o modelo linear, mas é simples o suficiente para não demandar uma carga de experimentos muito
    grande. Em meios bem ácidos (pH abaixo de 2), com uma concentração de ETRs na fase aquosa bem inferior à saturação
    e
    uma
    alta concentração de extratante na fase orgânica, um modelo de D função apenas do pH (ou melhor, de \([H^{+}]\))
    pode ser elaborado com uma capacidade de predição relativamente alta (\(R^2 \approx 0.95 \sim 0.99)\). </p>

  <p>
    Um modelo deste tipo foi criado para a separação de dois elementos de terras-raras: disprósio (Dy) e hólmio
    (Ho). O disprósio é um elemento de altíssimo valor agregado e a sua obtenção puro, no nosso país, ainda é um
    desafio e é incentivado por programas de financiamento federal para produção de ímãs especiais, com aplicações
    em motores elétricos de carros e turbinas eólicas, por exemplo.
  </p>
  <p>
    No processo, hólmio é um elemento com maior afinidade pelo extratante orgânico, de forma que o disprósio deverá
    sair puro pelo rafinado, e o hólmio carregado pela fase orgânica.
  </p>
  <p>
    Para cada estágio (ou célula) de extração, temos duas equações e duas variáveis. Entretanto, pelos balanços de
    massa, as equações de um estágio são interdependentes com as do próximo e do anterior. Dessa forma, um sistema
    com 10 estágios possui 20 equações e 20 variáveis (as concentrações de Dy e Ho em cada célula).
  </p>
  <p>
    A dedução completa das equações, abaixo, obtidas a partir do modelo, pode ser conferida <a
      href="https://drive.google.com/file/d/1oPydARsBiRtOOtMdmICFtRwClPqU7HY_/view?usp=sharing">aqui</a>.
    <b>Todas</b> as equações foram postas em termos das concentrações na fase <i>aquosa</i>.
  </p>
  <p><i>Não se preocupe com as concentrações na fase orgânica, embora pela dedução do balanço de massa mostrado em
      anexo seja facilmente percebível como elas podem ser obtidas.
    </i></p>
  <br>
  <br>
  <span style='font-size: 1.2em; color:rgb(101, 227, 243)'>Para qualquer estágio que não seja o último:</span>
  <section>
    $$
    \large
    \begin{cases}
    Dy_n \Bigg(\bigg({K \over 3 (Dy_n + Ho_n)} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} + R \Bigg) - Dy_{n+1}
    \Bigg(\bigg({K \over 3 (Dy_{n+1} + Ho_{n+1})} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} \Bigg) - Dy_{n-1} \cdot R = 0
    \\[4ex]
    Ho_n \Bigg(\bigg({K \over 3 (Dy_n + Ho_n)} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} + R \Bigg) - Ho_{n+1}
    \Bigg(\bigg({K \over 3 (Dy_{n+1} + Ho_{n+1})} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} \Bigg) - Ho_{n-1} \cdot R = 0
    \\
    \end{cases}
    $$
  </section>
  <span style='font-size: 1.2em; color:rgb(101, 227, 243)'>Para o último estágio:</span>
  <section>
    $$
    \large
    \begin{cases}
    Dy_n \Bigg(\bigg({K \over 3 (Dy_n + Ho_n)} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} + R \Bigg) - Dy_{n-1} \cdot R = 0
    \\[4ex]
    Ho_n \Bigg(\bigg({K \over 3 (Dy_n + Ho_n)} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} + R \Bigg) - Ho_{n-1} \cdot R = 0
    \\
    \end{cases}
    $$
  </section>
  <ul>
    <li>
      \(Dy\) e \(Ho\) são as respectivas concentrações dos cátions \([Etr^{3+}]\). Opte por trabalhar na unidade de
      mol/L, para o cálculo da constante de cargas, mais abaixo.
    </li>
    <li>
      \(n\) é o subscrito para o estágio atual. \(n+1\) o estágio da frente e \(n-1\) o estágio de trás. Para o
      primeiro estágio, haverá um \(n_0\), que será a corrente de alimentação.
    </li>
    <li>
      K é o número total de cargas (positivas ou negativas), que, pelo balanço de carga, será o mesmo para qualquer
      estágio, pois a fase orgânica é neutra.
    </li>
  </ul>

  <section>$$ K = [H_{0}^+] + 3[Dy_{0}^{3+}] + 3[Ho_{0}^{3+}]$$</section>

  <p>Lembrando que: \(pH = -log[H^+]\) e \([H^+] = 10^{-pH}\).</p>

  <h3 style='color:red'> Dados Experimentais </h3>
  <h3 style='color:red'>revisar após o término do algoritmo</h3>
  <p>
    Aqui você encontrará os dados para fazer uso das equações acima.

  </p>
  <ul>
    <li>Tolerância do método: \(t = 0.00001\)</li>
    <li>Nº de Estágios: \(n = 30\)</li>
    <li>Razão A/O: \(R = 2\)</li>
    <li>\(pH = 0.8\)</li>
    <li>\(Dy_0 = 8.06 \cdot 10^{-3} mol/L\)</li>
    <li>\(Ho_0 = 1.53 \cdot 10^{-2} mol/L\)</li>
    <li>Recomenda-se um chute inicial para os demais elementos do vetor x (\(\underline{x}\)) (ver seção abaixo), onde
      x são todas as concentrações de Dy \( (Dy_1, Dy_2, ..., Dy_{n}) \), seguidos por todas as concentrações de Ho
      \( (Ho_1, Ho_2, ..., Ho_{n}) \), como segue:
    </li>
    <li>
      Para um dado elemento, os chutes iniciais começando em 1 e terminando em n podem seguir uma progressão
      <i>decrescente</i> e <i>linear</i>, começando pelo valor de 100% do elemento com subscrito 0 (a alimentação da
      primeira célula) e terminando em 1% desse valor.
      <i>Note que a alimentação não tem um chute inicial para o modelo iterativo, ele é uma informação
        conhecida!</i>
    </li>
  </ul>

  <h2> Resolvendo um Sistema de Equações Não-Lineares </h2>

  <h3> Teoria </h3>

  <p>
    Para obter as raízes de um sistema de equações não lineares, o método Newton-Raphson pode ser usado. Da mesma
    forma que o usamos na Semana 3 para encontrar as raízes de uma equação, o usaremos agora para encontrar as raízes
    de um sistema delas.
  </p>
  <p>
    A dificuldade extra desse problema vem do fato de as equações serem interdependentes, o que requer alguns passos
    extras.
  </p>
  <p>
    Considere o sistema de equações não-lineares:
  </p>
  <section>
    $$
    \large
    \begin{cases}
    f_1(x_1, x_2, x_3, \dots, x_n) = 0 \\
    f_2(x_1, x_2, x_3, \dots, x_n) = 0 \\
    f_3(x_1, x_2, x_3, \dots, x_n) = 0 \\
    \vdots \\
    f_n(x_1, x_2, x_3, \dots, x_n) = 0 \\
    \end{cases}
    $$
  </section>
  <p>
    Para esse sistema, temos que:
  </p>
  <p>
    \(\underline{f}(\underline{x}) = \underline{0}\) , onde:
  </p>
  <p>
    Onde a barra embaixo indica um vetor coluna.
  </p>
  <p>
    Tendo um vetor de x's ( \( \underline{x} \) ), como chute inicial, da mesma forma que se havia um ponto x como
    chute
    inicial, quando lidávamos com apenas uma função, podemos obter o próximo conjunto de pontos em \(\underline{x}\)
    calculando as funções e suas respectivas derivadas.
  </p>
  <p>
    Se você notar, o próximo chute é apenas traçar uma reta, com a inclinação igual à derivada da função, até o
    próximo ponto em que \(f(x) = 0\).
  </p>
  <p>
    Isso é essencialmente, extrapolar o comportamento em \(f(x^{(0)})\) para \(f(x^{(1)})\), truncando a função no
    primeiro termo da série de Taylor, que vimos na semana 6. Como essa aproximação geralmente não é boa, \(x^{(1)}\)
    costuma não se suficiente, sendo necessário repetir o processo, para com \(x^{(1)}\) gerar \(x^{(2)}\) e assim por
    diante.
  </p>
  <p>
    <i>O número sobrescrito faz referência ao número da iteração.</i>
  </p>
  <p>
    Se para uma função com uma raíz tínhamos que:
  </p>
  <section>
    $$ \large
    x^{(n+1)} = x^{(n)} - { f( x^{ (n) } ) \over f'( x^{ (n) } ) }$$
  </section>
  <p>
    Agora temos que:
  </p>
  <section>
    $$\large \underline{x}^{(n+1)} = \underline{x}^{(n)} - (\underline{\underline{J}}^{(n)})^{-1} \cdot
    \underline{f}(\underline{x}^{(n)}) (1)$$
  </section>
  <section>
    $$\large (\underline{\underline{J}}^{(n)})^{-1} \cdot \underline{f}(\underline{x}^{(n)}) = \Delta
    \underline{x}^{(n)} (2)$$
  </section>
  <ul>
    <li>Onde J é a matriz Jacobiana do sistema.</li>
    <li>O sobrescrito \(-1\) indica que é a matriz inversa.</li>
    <li>O sobrescrito \(n\) indica a n-ésima iteração.</li>
    <li>O duplo traço embaixo da matriz é uma notação comum para indicar uma matriz (bidimensional, em distinção ao
      vetor, com apenas um traço, que é unidimensional).</li>
    <li>Jogando \(\underline{x}^{(n)}\) em (1) para a esquerda, (2) é obviamente verificável.</li>
  </ul>
  <p>
    A matriz Jacobiana de um sistema de equações, conforme o exposto acima, será dado por:
  </p>
  <p>
    $$
    \Large
    J =
    \begin{bmatrix}
    \frac{\partial f_1}{\partial x_1} &
    \frac{\partial f_1}{\partial x_2} &
    \frac{\partial f_1}{\partial x_3} &
    \dots &
    \frac{\partial f_1}{\partial x_n}
    \\[1ex]
    \frac{\partial f_2}{\partial x_1} &
    \frac{\partial f_2}{\partial x_2} &
    \frac{\partial f_2}{\partial x_3} &
    \dots &
    \frac{\partial f_2}{\partial x_n}
    \\[1ex]
    \frac{\partial f_3}{\partial x_1} &
    \frac{\partial f_3}{\partial x_2} &
    \frac{\partial f_3}{\partial x_3} &
    \dots &
    \frac{\partial f_3}{\partial x_n} \\[1ex]
    \vdots & \vdots & \vdots & \ddots & \\
    \frac{\partial f_n}{\partial x_1} &
    \frac{\partial f_n}{\partial x_2} &
    \frac{\partial f_n}{\partial x_3} &
    \dots &
    \frac{\partial f_n}{\partial x_n} \\[1ex]
    \end{bmatrix}
    $$
  </p>
  <p>
    Nesse algoritmo, a atualização de um determinado x em \( \underline{x} \) é dado não só pelo comportamento dele em
    particular com uma função, mas o comportamento de todo o \(\underline{x}\) em relação a todo o
    \(\underline{f}(\underline{x})\). O algoritmo termina quando \(\Delta \underline{x}^{(n)} \rightarrow t\) , onde
    \(t\) é
    a tolerância do método, que indica o quão pequeno um erro deve ser, para que em termos práticos o resultado tenha
    sido o mesmo que encontrar as raízes (\(\underline{f}(\underline{x}) \rightarrow \underline{0}\)).
  </p>
  <p>
    Quando isso acontece, significa que houve uma convergência. O algoritmo é enviesado, porque ele irá achar a raíz
    mais próxima, não a que você quer ou todas elas.
  </p>
  <h3> Construindo um algoritmo para a resolução do sistema </h3>
  <p><i>Esta é uma sugestão de construção, lembrando que existem inúmeras soluções para um mesmo problemas, que podem
      ser, inclusive, melhores do que aquela aqui apresentada.</i></p>
  <ol>
    <li>
      <span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Criar o vetor <b>coluna</b> com os chutes iniciais de
        \(x\) ( \( \underline{x} \) ).</span>
    </li>
    <li>
      <span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Construir um montador de equações.</span>
      <ol>
        <li>A ideia desse montador é gerar equações \(f(\underline{x}) = \underline{0}\).</li>
        <p><i>O lado direito da equação será omitido no método. Tudo deve ser passado para o lado esquerdo.</i></p>
      </ol>
    </li>
    <li>
      <span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Construir um montador de vetores <b>coluna</b> de
        \(f\).</span>
      <ol>
        <li>A ideia desse montador de vetores é chamar o montador de equações tantas vezes quanto houver estágios,
          para
          gerar o vetor de funções \(\underline{f}(\underline{x}) \).</li>
      </ol>
    </li>
    <li>
      <span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Construir a matriz Jacobiana.</span>
      <ol>
        <li>Criar uma função que gera uma matriz quadrada <i>template</i>, que só possui zeros, que será do mesmo
          tamanho que a matriz Jacobiana final.</li>
        <li>Construir uma função que recebe \(f_n(x_j)\) e retorna \(\large {\partial f_n \over \partial x_j}\).
          \(i\) e \(j\) são valores inteiros genéricos entre 1 e \(n\), da matriz Jacobiana mostrada.</li>
        <li>Atualizar a matriz de zeros com os valores de \(\large {\partial f_n \over \partial x_j}\) obtidos.
          <i>
            É muito importante que você escreva sua matriz Jacobiana de forma que todas as linhas possuam um <a
              href="https://en.wikipedia.org/wiki/Pivot_element">pivô</a>
            . Para o nosso caso, isso significa dizer que \(\large
            {\partial f_n \over \partial x_n} \neq 0\). Do contrário, a eliminação Gaussiana (ver adiante) não irá
            funcionar.
          </i>
        </li>
      </ol>
    </li>
    <li>
      <span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Construir a <a
          href="(https://www.purplemath.com/modules/mtrxinvr.htm)">matriz
          inversa</a> da Jacobiana.</span>
      <ol>
        <li>Use a função que cria uma matriz template de zeros para criar uma matriz identidade com o mesmo tamanho da
          matriz Jacobiana.</li>
        <li>Construir um algoritmo de <a href="https://pt.wikipedia.org/wiki/Elimina%C3%A7%C3%A3o_de_Gauss">Eliminação
            Gaussiana</a>
          <ol>
            <li>Criar uma função que zera os elementos da coluna do pivô.
              <i>
                Seja \(L_n\) o pivô da linha i (\(l_n\)). Seja \(L_j\) um elemento da linha j ( \(l_j \) )na mesma
                coluna de \(L_n\). Nós podemos zerar \(L_j\), atualizando a \(l_j\) com o resultado da seguinte
                operação:
              </i>
              <section>$$\large l_j = l_j - l_n \cdot {L_j \over L_n}$$</section>
            </li>
            <li>Criar uma função que utiliza 5.2.1 para zerar a diagonal de inferior da matriz.</li>
            <li>Criar uma função que recebe o resultado de 5.2.2 e utiliza 5.2.1 para zerar a diagonal superior.</li>
            <li>Agora que só existem elementos na diagonal, a matriz inversa será finalmente obtida no lado direito
              dividindo cada linha por si mesmo, de forma a obter a matriz identidade do lado esquerdo.
              <i>Toda operação que você fizer na matriz Jacobiana em 5.2.1, ao longo de 5.2.2 e 5.2.3, a matriz
                identidade criada em 5.1.1 deverá seguir, um espelhamento. Igualmente, as divisões em 5.2.4 deverão
                ser
                aplicadas na matriz do lado direito.</i>
            </li>
            <div>
              <p>A matriz deverá entrar assim em 5.2.2:</p>
              <section>
                $$
                \large
                M =
                \begin{bmatrix}
                a_{11} & a_{12} & a_{13} & a_{14} & | & 1 & 0 & 0 & 0 \\
                a_{21} & a_{22} & a_{23} & a_{24} & | & 0 & 1 & 0 & 0 \\
                a_{31} & a_{32} & a_{33} & a_{34} & | & 0 & 0 & 1 & 0 \\
                a_{41} & a_{42} & a_{43} & a_{44} & | & 0 & 0 & 0 & 1 \\
                \end{bmatrix}
                $$
              </section>
              <p>A matriz deverá sair assim de 5.2.2, e entrar da mesma forma em 5.2.3:</p>
              <section>
                $$
                \large
                M =
                \begin{bmatrix}
                a_{11} & a_{12} & a_{13} & a_{14} & | & 1 & 0 & 0 & 0 \\
                0 & b_{22} & b_{23} & b_{24} & | & z_{21} & 1 & 0 & 0 \\
                0 & 0 & b_{33} & b_{34} & | & z_{31} & z_{32} & 1 & 0 \\
                0 & 0 & 0 & b_{44} & | & z_{41} & z_{42} & z_{43} & 1 \\
                \end{bmatrix}
                $$
              </section>
              <p>A matriz deverá sair assim de 5.2.3, e entrar da mesma forma em 5.2.4:</p>
              <section>
                $$
                \large
                M =
                \begin{bmatrix}
                a_{11} & 0 & 0 & 0 & | & z_{11} & z_{12} & z_{13} & z_{14} \\
                0 & b_{22} & 0 & 0 & | & z_{21} & z_{22} & z_{23} & z_{24} \\
                0 & 0 & b_{33} & 0 & | & z_{31} & z_{32} & z_{33} & z_{34} \\
                0 & 0 & 0 & b_{44} & | & z_{41} & z_{42} & z_{43} & 1 \\
                \end{bmatrix}
                $$
              </section>
              <p>A matriz deverá sair de 5.2.4 assim:</p>
              <section>
                $$
                \large
                M =
                \begin{bmatrix}
                1 & 0 & 0 & 0 & | & {z_{11} \over a_{11}} & {z_{12} \over a_{11}} & {z_{13} \over a_{11}} & {z_{14}
                \over a_{11}}
                \\[1ex]
                0 & 1 & 0 & 0 & | & {z_{21} \over b_{22}} & {z_{22} \over b_{22}} & {z_{23} \over b_{22}} & {z_{24}
                \over b_{22}}
                \\[1ex]
                0 & 0 & 1 & 0 & | & {z_{31} \over b_{33}} & {z_{32} \over b_{33}} & {z_{33} \over b_{33}} & {z_{34}
                \over b_{33}}
                \\[1ex]
                0 & 0 & 0 & 1 & | & {z_{41} \over b_{44}} & {z_{42} \over b_{44}} & {z_{43} \over b_{44}} & {1 \over
                b_{44} }
                \\[1ex]
                \end{bmatrix}
                $$
              </section>
              <p><i>As novas letras apenas denotam uma mudança de valor.</i></p>
            </div>
          </ol>
        </li>
      </ol>
    </li>
    <li><span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Criar uma função que faz a <a
          href="https://en.wikipedia.org/wiki/Matrix_multiplication">Multiplicação de Matrizes</a></span>
      $$\large (\underline{\underline{J}}^{(n)})^{-1} \cdot \underline{f}(\underline{x}^{(n)})$$
    </li>
    <li><span style='font-size: 1.2em; color:rgb(101, 227, 243)'> Construir a função principal
        (Newton-Raphson):</span>
      <ol>
        <li> Criar as funções suporte:
          <ol>
            <li>Criar uma função que analisa a convergência.
              <i>Ela irá analisar o vetor produzido por \((\underline{\underline{J}}^{(n)})^{-1} \cdot
                \underline{f}(\underline{x}^{(n)})\) e verificar se todos os elementos do vetor são menores do que
                zero.</i>
            </li>
            <li>Criar uma função que atualiza \(\underline{x}^{(n)}\) com \(\Delta \underline{x}^{(n)}\), para gerar
              \(\underline{x}^{(n+1)}\).</li>
          </ol>
        </li>
        <li>Enquanto não houver convergência dos valores ela deverá:
          <ol>
            <li>Gerar o vetor \(\underline{x}^{(n)}\)</li>
            <li>Gerar o vetor \(\underline{f}(\underline{x}^{(n)})\)</li>
            <li>Gerar a matriz jacobiana</li>
            <li>Inverter a matriz</li>
            <li>Gerar \(\Delta \underline{x}^{(n)} = (\underline{\underline{J}}^{(n)})^{-1} \cdot
              \underline{f}(\underline{x}^{(n)})\)</li>
            <li>Decidir se houve convergência.</li>
            <li>Atualizar os valores de \(\underline{x} \rightarrow \underline{x}^{(n+1)} = \underline{x}^{(n)} +
              \Delta
              \underline{x}^{(n)}\)</li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <h3><span>Para não restar dúvidas</span></h3>
  <p>O seu vetor de funções \(\underline{f}(\underline{x})\)</p>
  <section>
    $$
    \large
    \begin{bmatrix}
    f_1(x_1, x_2, x_3, \dots, x_n) \\
    f_2(x_1, x_2, x_3, \dots, x_n) \\
    f_3(x_1, x_2, x_3, \dots, x_n) \\
    \vdots \\
    f_n(x_1, x_2, x_3, \dots, x_n) \\
    \end{bmatrix}
    $$
  </section>
  <p>Deverá ficar assim:</p>
  <section>
    $$
    \begin{bmatrix}

    f_1 = Dy_1 \Bigg(\bigg({K \over 3 (Dy_1 + Ho_1)} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} + R \Bigg) - Dy_{2}
    \Bigg(\bigg({K \over 3 (Dy_{2} + Ho_{2})} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} \Bigg) - Dy_{0} \cdot R \\[4ex]

    f_2 = Dy_2 \Bigg(\bigg({K \over 3 (Dy_2 + Ho_2)} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} + R \Bigg) - Dy_{3}
    \Bigg(\bigg({K \over 3 (Dy_{3} + Ho_{3})} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} \Bigg) - Dy_{1} \cdot R \\[4ex]

    \vdots \\[4ex]

    f_{n-1} = Dy_{n-1} \Bigg(\bigg({K \over 3 (Dy_{n-1} + Ho_{n-1})} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} + R \Bigg) -
    Dy_{n} \Bigg(\bigg({K \over 3 (Dy_{n} + Ho_{n+1})} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} \Bigg) - Dy_{n-2} \cdot R
    \\[4ex]

    f_{n} = Dy_n \Bigg(\bigg({K \over 3 (Dy_n + Ho_n)} \bigg)^{-a_{Dy}} \cdot 10^{b_{Dy}} + R \Bigg) - Dy_{n-1} \cdot
    R \\[4ex]

    f_{n+1} = Ho_1 \Bigg(\bigg({K \over 3 (Dy_{1} + Ho_{1})} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} + R \Bigg) -
    Ho_{2} \Bigg(\bigg({K \over 3 (Dy_{2} + Ho_{2})} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} \Bigg) - Ho_{0} \cdot R
    \\[4ex]

    f_{n+2} = Ho_2 \Bigg(\bigg({K \over 3 (Dy_2 + Ho_2)} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} + R \Bigg) - Ho_{3}
    \Bigg(\bigg({K \over 3 (Dy_{3} + Ho_{3})} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} \Bigg) - Ho_{1} \cdot R \\[4ex]

    \vdots \\[4ex]

    f_{2n-1} = Ho_{n-1} \Bigg(\bigg({K \over 3 (Dy_{n-1} + Ho_{n-1})} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} + R \Bigg) -
    Ho_{n} \Bigg(\bigg({K \over 3 (Dy_{n} + Ho_{n})} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} \Bigg) - Ho_{n-2} \cdot R
    \\[4ex]

    f_{2n} = Ho_{n} \Bigg(\bigg({K \over 3 (Dy_n + Ho_n)} \bigg)^{-a_{Ho}} \cdot 10^{b_{Ho}} + R \Bigg) - Ho_{n-1}
    \cdot R \\[4ex]

    \end{bmatrix}
    $$
  </section>
  <p>Onde \(n\) é o número de estágios de separação. Logo, com 10 estágios de separação, haverão 20 linhas no vetor
    (indo de 0 até 19).</p>
  <p>A sua Matriz Jacobiana deverá ficar assim:</p>
  <section>
    $$
    \large
    J =
    \begin{bmatrix}
    \frac{\partial f_1}{\partial Dy_1} &
    \frac{\partial f_1}{\partial Dy_2} &
    \dots & \dots & \dots & \dots &
    \frac{\partial f_1}{\partial Ho_1} &
    \frac{\partial f_1}{\partial Ho_2} &
    \dots & \dots & \dots & \dots &
    \\[1ex]

    \frac{\partial f_2}{\partial Dy_1} &
    \frac{\partial f_2}{\partial Dy_2} &
    \frac{\partial f_2}{\partial Dy_3} &
    \dots & \dots & \dots & \dots &
    \frac{\partial f_2}{\partial Ho_2} &
    \frac{\partial f_2}{\partial Ho_3} &
    \dots & \dots & \dots &
    \\[1ex]

    \dots &
    \frac{\partial f_3}{\partial Dy_2} &
    \frac{\partial f_3}{\partial Dy_3} &
    \frac{\partial f_3}{\partial Dy_4} &
    \dots & \dots & \dots & \dots &
    \frac{\partial f_3}{\partial Ho_3} &
    \frac{\partial f_3}{\partial Ho_4} &
    \dots & \dots &
    \\[4ex]

    \vdots & \vdots & \vdots & \vdots & \vdots & \vdots &
    \vdots & \vdots & \vdots & \vdots & \vdots & \vdots &\\[4ex]

    \dots & \dots & \dots &
    \frac{\partial f_{n-1}}{\partial Dy_{n-2}} &
    \frac{\partial f_{n-1}}{\partial Dy_{n-1}} &
    \frac{\partial f_{n-1}}{\partial Dy_{n}} &
    \dots & \dots & \dots & \dots &
    \frac{\partial f_{n-1}}{\partial Ho_{n-1}} &
    \frac{\partial f_{n-1}}{\partial Ho_{n}} &
    \\[1ex]

    \dots & \dots & \dots & \dots &
    \frac{\partial f_{n}}{\partial Dy_{n-1}} &
    \frac{\partial f_{n}}{\partial Dy_{n}} &
    \dots & \dots & \dots & \dots & \dots &
    \frac{\partial f_{n}}{\partial Ho_{n}} &
    \\[4ex]

    \frac{\partial f_{n+1}}{\partial Dy_1} &
    \frac{\partial f_{n+1}}{\partial Dy_2} &
    \dots & \dots & \dots & \dots &
    \frac{\partial f_{n+1}}{\partial Ho_1} &
    \frac{\partial f_{n+1}}{\partial Ho_2} &
    \dots & \dots & \dots & \dots &
    \\[1ex]

    \dots &
    \frac{\partial f_{n+2}}{\partial Dy_2} &
    \frac{\partial f_{n+2}}{\partial Dy_3} &
    \dots & \dots & \dots &
    \frac{\partial f_{n+2}}{\partial Ho_1} &
    \frac{\partial f_{n+2}}{\partial Ho_2} &
    \frac{\partial f_{n+2}}{\partial Ho_3} &
    \dots & \dots & \dots &
    \\[1ex]

    \dots & \dots &
    \frac{\partial f_{n+3}}{\partial Dy_3} &
    \frac{\partial f_{n+3}}{\partial Dy_4} &
    \dots & \dots & \dots &
    \frac{\partial f_{n+3}}{\partial Ho_2} &
    \frac{\partial f_{n+3}}{\partial Ho_3} &
    \frac{\partial f_{n+3}}{\partial Ho_4} &
    \dots & \dots &
    \\[4ex]

    \vdots & \vdots & \vdots & \vdots & \vdots & \vdots &
    \vdots & \vdots & \vdots & \vdots & \vdots & \vdots &\\[4ex]

    \dots & \dots & \dots & \dots &
    \frac{\partial f_{2n-1}}{\partial Dy_{n-1}} &
    \frac{\partial f_{2n-1}}{\partial Dy_{n}} &
    \dots & \dots & \dots &
    \frac{\partial f_{2n-1}}{\partial Ho_{n-2}} &
    \frac{\partial f_{2n-1}}{\partial Ho_{n-1}} &
    \frac{\partial f_{2n-1}}{\partial Ho_{n}} &
    \\[1ex]

    \dots & \dots & \dots & \dots & \dots &
    \frac{\partial f_{2n}}{\partial Dy_{n}} &
    \dots & \dots & \dots & \dots &
    \frac{\partial f_{2n}}{\partial Ho_{n-1}} &
    \frac{\partial f_{2n}}{\partial Ho_{n}} &
    \\[4ex]

    \end{bmatrix}
    $$
  </section>
  <p><i>Note que é necessário que a Jacobiana seja uma matriz quadrada, para que o número de variáveis seja igual ao
      de
      equações.</i></p>
  <p><i>Note que no estágio 1, por exemplo, temos as equações \(f_1\) e \(f_{n+1}\) que se referem ao balanço de
      massa,
      do Dy e do Ho, respectivamente. As únicas variáveis que aparecem nessas equações são \(Dy_1\), \(Dy_2\),
      \(Ho_1\)
      e \(Ho_2\); logo, as derivadas em relação à quaisquer outros elementos que não sejam esses dois serão zero,
      sempre. Dessa forma, a matriz de zeros que você construiu já estará bem "preenchida". Note que na forma disposta
      ela tem todos os pivôs, muito importante para a resolução utilizando a Eliminação Gaussiana.</i></p>

  <h2><span> Sobre a Avaliação</span></h2>
  <h3><span> Como será a avaliação </span></h3>

  <ol>
    <li>Você realizará uma apresentação, em horário a combinar, para apresentar o seu projeto.</li>
    <li>Não é necessário montar uma apresentação ou escrever um relatório. Entretanto, a construção de um pseudocódigo
      é
      encorajada para a explicação do mesmo.</li>
    <li>O código e o pseudocódigo são os recursos visuais adequados para a apresentação.</li>
    <li>O código deve ser enviado com, <b>no mínimo</b>, 24 horas de antecedência à apresentação, para exame prévio.
    </li>
    <li>É ideal que a apresentação não tenha mais de 10 minutos, somados a 10 minutos de arguição. A arguição será
      tanto
      da apresentação quanto do código enviado previamente.</li>
  </ol>

  <h3><span> Para a aprovação </span></h3>

  <ol>
    <li>Você precisará obter uma pontuação mínima 7/10.</li>
    <li>Um feedback demarcando a pontuação e os erros identificados serão mostrados e são passíveis de revisão, por
      qualquer uma das partes que se manifeste.</li>
    <li>Em caso de reprovação, você terá o direito de fazer uma nova apresentação, marcando um novo horário. É
      esperado
      que você use o feedback recebido para consertar o seu código.</li>
  </ol>

  <h3><span> O que será avaliado </span></h3>

  <ol>
    <li>Apresentação estética do código (1/10)
      <ol>
        <li>Espaçamento de caracteres e linhas consistente. (0.5/1)</li>
        <li>Indentação consistente. (0.5/1)</li>
      </ol>
    </li>
    <li>
      Legibilidade do código (3/10)
      <ol>
        <li>Nomenclatura adequada de variáveis, funções, objetos, métodos, etc. (1/3)</li>
        <li>Comentários, onde for adequado, e com parcimônia. (1/3)</li>
        <li>Usar sintaxes condensadas quando adequado (compreensão de listas, map, funções lambda, etc.) (1/3)</li>
      </ol>
    </li>
    <li>Capacidade de descrever/apresentar a resolução de maneira clara (3/10)
      <ol>
        <li>Descrever/apresentar a estrutura do código. (2/3)</li>
        <li>Descrever/apresentar possíveis melhorias ao código. (1/3)
          <ol>
            <li>Onde considerar cabível, apontar redundância, pontos para refatoramento, reescrita para clareza, etc.
              (1/1)</li>
          </ol>
        </li>
      </ol>
    </li>
    <li>O código (3/10)
      <ol>
        <li>Funções/Métodos/Objetos sem sobracarga de responsabilidade. (0.5/3)</li>
        <li>Resultados Parciais. (1/3)
          <ol>
            <li>Correto</li>
            <li>Se incorreto, apontar onde está o erro.</li>
          </ol>
        </li>
        <li>Resultado. (1.5/3)
          <ol>
            <li>Correto</li>
            <li>Se incorreto, apontar onde está o erro.</li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <h3><span> Recomendações </span></h3>
  <ol>
    <li>Não exite em tirar dúvidas</li>
    <li>Recicle código dos notebooks</li>
    <li>A organização do código e atribuição de responsabilidade tende a ser naturalmente facilitada pela utilização
      do
      paradigma de orientação a objetos. Considere sua utilização.</li>
    <li>Um resultado correto demanda tempo e paciência.
      <i>De toda forma, note que é possível gabaritar o projeto sem ter acertado o valor final.</i>
    </li>
  </ol>
</body>

</html>